{"name":"Herring","tagline":"A Python Make Utility","body":"\r\nHerring\r\n=======\r\n\r\nHerring is a simple python make utility.  You write tasks in python, and\r\noptionally assign dependent tasks.  The command line interface lets you easily\r\nlist the tasks and run them.\r\n\r\n\"First you must find... another shrubbery! (dramatic chord) Then, when you have\r\nfound the shrubbery, you must place it here, beside this shrubbery, only\r\nslightly higher so you get a two layer effect with a little path running down\r\nthe middle. (\"A path! A path!\") Then, you must cut down the mightiest tree in\r\nthe forrest... with... a herring!\"\r\n\r\nUsage\r\n-----\r\n\r\nTasks are defined by using a @task decorator on a function definition in the\r\nproject's herringfile::\r\n\r\n    @task()\r\n    def foo():\r\n        \"\"\" Do something fooey \"\"\"\r\n        #...\r\n\r\nTask decorators can take optional keywords::\r\n\r\n    :depends: List of task names as strings.\r\n    :help: Text that will be shown as notes when showing tasks (ex: running \"herring -T\").\r\n    :namespace: The namespace for the task.\r\n    :private: A boolean that can be used to declare a task private.\r\n\r\nThis example defines task \"test::bar\" that is dependent on task \"foo\"::\r\n\r\n    @task(namespace='test', depends=['foo'], help=\"doesn't do anything\")\r\n    def bar():\r\n        \"\"\" The bar for foo \"\"\"\r\n\r\nTask Scopes\r\n-----------\r\n\r\nNormal tasks (with docstrings) are public by default while hidden tasks (without docstrings)\r\nare private.  You can make a public task private by setting the private attribute to True.\r\nDeclaring a task private lets you keep the docstring but hide the task from normal task list.\r\nMore on task scopes later.\r\n\r\nNamespaces\r\n----------\r\n\r\nNamespaces are a grouping mechanism for tasks, not to be confused with python\r\nnamespace/packages.  The purpose is so you can easily group related tasks\r\nwithout using a naming convention.\r\n\r\nFor example say you had the following three documentation tasks::\r\n\r\n    @task(depends=['doc_generate_icon'])\r\n    def doc_sphinx():\r\n        pass\r\n\r\n    @task()\r\n    def doc_generate_icon()\r\n        pass\r\n\r\n    @task(depends=['doc_sphinx'])\r\n    def doc()\r\n        pass\r\n\r\nUsing namespaces you could have something like::\r\n\r\n    with namespace('doc'):\r\n\r\n        @task(depends=['doc::generate_icon'])\r\n        def sphinx():\r\n            pass\r\n\r\n        @task()\r\n        def generate_icon()\r\n            pass\r\n\r\n    @task(depends=['doc::sphinx'])\r\n    def doc()\r\n        pass\r\n\r\nNote that you may use multiple namespaces within the same module or even have tasks from different\r\nmodules in the same namespace.\r\n\r\nAlso that namespaces do not affect directly calling a method.  So you may simply call the **generate_icon()**\r\nmethod directly.  Calling the method directly does not run the task's dependencies.  To run a task with it's\r\ndependencies, use the **task_execute()** function.  For example::\r\n\r\n    task_execute('doc')\r\n\r\nwill run the doc::sphinx dependency then the doc() task.\r\n\r\nYou may run multiple tasks by giving task_execute a list of tasks::\r\n\r\n    task_execute(['generate_icon', 'sphinx'])\r\n\r\nRunning a Task\r\n--------------\r\n\r\nTo run a task, simply be in the directory with your herringfile or one of it's\r\nsub-directories and to run the **doc** task, type::\r\n\r\n    herring doc\r\n\r\nthis will run the **doc::generate_icon** task then the **doc::sphinx** task then the **doc** task::\r\n\r\n\r\nCommand Line Arguments\r\n----------------------\r\n\r\nTo pass arguments to the task, simply place them on the command line as keyword\r\narguments.  The tasks may access the lists by using::\r\n\r\n    task.argv\r\n\r\nOr already parsed as keyword args by using::\r\n\r\n    task.kwargs\r\n\r\nExample::\r\n\r\n    @task()\r\n    def argDemo():\r\n        print(\"argv: %s\" % repr(task.argv))\r\n        print(\"kwargs: %s\" % repr(task.kwargs))\r\n\r\n    herring argDemo --delta=3 --flag\r\n\r\noutputs::\r\n\r\n    argv: ['--delta=3', '--flag']\r\n    kwargs: ['delta': 3, 'flag': True]\r\n\r\nAvailable Tasks\r\n---------------\r\n\r\nTo see the list of available tasks, run::\r\n\r\n    herring -T\r\n    Show tasks\r\n    ============================================================\r\n    herring foo        # Do something fooey\r\n    herring bar        # The bar for foo\r\n\r\nIf you do not include a docstring for a task, then the task is hidden (private) and will not\r\nshow up in the list, although it can still be ran.\r\n\r\nTo show all tasks, including hidden tasks::\r\n\r\n    herring --all\r\n\r\nReusing Tasks\r\n-------------\r\n\r\nHerring supports loading files from a \"herringlib\" directory.  This can be a single directory\r\nor the union of several directories.  If the later, then herring will search for directories\r\nto include in the union in the following order:\r\n\r\n1. any directories specified with the command line option --herringlib,\r\n2. a \"herringlib\" sub-directory to the directory that contains the \"herringfile\" file,\r\n3. the directory specified in the \"HERRINGLIB\" environment variable,\r\n4. the \"~/.herring/herringlib\" directory.\r\n\r\nThe union is created with the first found directory being the top most.  This means that if the\r\nsame filename exists in multiple found directories, the version in the first found directory will\r\nbe used.\r\n\r\nTechnically herring will create a temporary directory and copy the contents from the found directories\r\nin the order found but not overwriting files.  Herring automatically deletes this temporary directory\r\nunless you tell it not to with the --leave_union_dir flag (sometimes useful for debugging).\r\n\r\nThe environment variable approach is good for using a common set of tasks among a group of projects.\r\nThe sub-directory approach is good for using project specific tasks.\r\nThe \"~/.herring/herringlib\" approach is good for having your own set of default tasks.\r\n\r\nHerring will attempt to load all .py files in the virtual \"herringlib\" directory (glob: \"herringlib/\\*\\*/\\*.py\").\r\nThese .py files may include tasks just like the herringfile.\r\n\r\nYou will probably want to include __init__.py in herringlib and it's sub-directories so\r\nyou can easily import the modules in your herringfile.\r\n\r\nRecommended practice is to group related tasks and support methods in modules in\r\nthe herringlib directory.  Making these tasks project independent facilitates code\r\nreuse.  See the *herringlib* project (https://github.com/royw/herringlib) for some\r\nreusable herring tasks.\r\n\r\nQuick Project Initialization using herringlib project\r\n-----------------------------------------------------\r\n\r\nHerring with herringlib can initialize a new project with a herringfile and a set of generic\r\ntasks in the herringlib.  Further this set of generic tasks can populate your\r\nproject with common infrastructure files.\r\n\r\nInstall Herring into your system python::\r\n\r\n    ➤ sudo pip install Herring\r\n\r\nYou can install the herringlib tasks into the project and/or install them for all\r\nyour projects by clone them into your ~/.herring directory::\r\n\r\n    ➤ mkdir -p ~/.herring\r\n    ➤ cd ~/.herring\r\n    ➤ git clone https://github.com/royw/herringlib.git\r\n\r\nWhile in your ~/.herring directory you may want to create a ~/.herring/herring.conf file with some\r\ndefaults for your projects.  For example::\r\n\r\n    ➤ cat ~/.herring/herring.conf\r\n    [Herring]\r\n\r\n    [project]\r\n    author: wrighroy\r\n    author_email: roy.wright@example\r\n    dist_host: pypi.example.com\r\n    pypi_path: /var/pypi/dev\r\n\r\nThe [Herring] section is for command line options to herring.  The [project] section is for the defaults\r\nin herringlib's Project object (see the generated herringfile and this will make sense).\r\n\r\nHere's an example session showing the quick project initialization.\r\n\r\nEither create a new project or start a new one.\r\n\r\nChange to the project's directory then create a herringfile::\r\n\r\n    ➤ touch herringfile\r\n\r\nCreate the development environment by running::\r\n\r\n    ➤ herring project::init\r\n\r\nthis will give you a boilerplate herringfile and populate the herringlib directory with reusable tasks.\r\n\r\n.. note::\r\n\r\n    Project::init will provide a CLI application boilerplate code in the Project.package directory.  On\r\n    existing projects you probably want to delete these.\r\n\r\nEdit your herringfile, mainly verifying or changing the dictionary values being passed to Project.metadata().\r\n\r\nTo see all settings with their current values::\r\n\r\n    ➤ herring project::describe\r\n\r\nNow you can create the virtual environments for your project with:\r\n\r\n    ➤ herring project::mkvenvs\r\n\r\nFinally you are ready to develop your project.  The following are typical command flow::\r\n\r\n    ➤ herring test\r\n    ➤ herring version::bump\r\n    ➤ git add -A\r\n    ➤ git commit -m 'blah...'\r\n    ➤ herring build\r\n    ➤ herring doc\r\n    ➤ herring deploy doc::publish\r\n\r\nTo see a list of public tasks:\r\n\r\n    ➤ herring -T\r\n\r\n\r\nCommand line help is available\r\n==============================\r\n\r\nTo display the help message::\r\n\r\n    ➤ herring/herring_main.py --help\r\n    usage: Herring [-h] [-c FILE] [-f FILESPEC] [--herringlib [DIRECTORY [DIRECTORY ...]]] [-T] [-U] [-D] [-a] [-q] [-d]\r\n                   [--herring_debug] [--leave_union_dir] [-j] [-v] [-l]\r\n                   [tasks [tasks ...]]\r\n\r\n    \"Then, you must cut down the mightiest tree in the forrest... with... a herring!\" Herring is a simple python make\r\n    utility. You write tasks in python, and optionally assign dependent tasks. The command line interface lets you easily\r\n    list the tasks and run them. See --longhelp for details.\r\n\r\n    optional arguments:\r\n      -h, --help                  show this help message and exit\r\n      -c FILE, --conf_file FILE   Configuration file in INI format (default: ['.herringrc',\r\n                                  '/home/wrighroy/.herring/herring.conf', '/home/wrighroy/.herringrc'])\r\n\r\n    Config Group:\r\n\r\n      -f FILESPEC, --herringfile FILESPEC\r\n                                  The herringfile name to use, by default uses \"herringfile\".\r\n      --herringlib [DIRECTORY [DIRECTORY ...]]\r\n                                  The location of the herringlib directory to use (default: ['herringlib',\r\n                                  '~/.herring/herringlib']).\r\n\r\n    Task Commands:\r\n\r\n      -T, --tasks                 Lists the public tasks (with docstrings).\r\n      -U, --usage                 Shows the full docstring for the tasks (with docstrings).\r\n      -D, --depends               Lists the tasks (with docstrings) with their dependencies.\r\n      tasks                       The tasks to run. If none specified, tries to run the 'default' task.\r\n\r\n    Task Options:\r\n\r\n      -a, --all                   Lists all tasks, even those without docstrings.\r\n\r\n    Output Options:\r\n\r\n      -q, --quiet                 Suppress herring output.\r\n      -d, --debug                 Display task debug messages.\r\n      --herring_debug             Display herring debug messages.\r\n      --leave_union_dir           Leave the union herringlib directory on disk (do not automatically erase). Useful for\r\n                                  debugging.\r\n      -j, --json                  Output list tasks (--tasks, --usage, --depends, --all) in JSON format.\r\n\r\n    Informational Commands:\r\n\r\n      -v, --version               Show herring's version.\r\n      -l, --longhelp              Long help about Herring.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}